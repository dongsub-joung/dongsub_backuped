---
title: Django 기초 이론
tag: Django
---



## Django Views

### 정의

 View들은 Django App 안의 views.py 라는 파일에 정의하게 되는데, 각 함수가 하나의 View를 정의한다. 각 View는 HTTP Request를 입력 파라미터로 받아들이고, HTTP Response를 리턴한다.

 View는 (1) 웹페이지 내용을 갖는 HttpResponse 객체를 리턴하거나 (2) Http404 같은 Exception을 리턴한다.

#### 404

```python
from django.http import Http404, HttpResponseNotFound

def error(request):
	#return HttpResponseNotFound('<h1> not found </h1>')
	raise Http404("Not Found")
```



### MTV 패턴

MTV에서의 Model은 데이타를 표현하는데 사용되며, 하나의 모델 클래스는 DB에서 하나의 테이블로 표현된다.

MTV의 View는 HTTP Request를 받아 그 결과인 HTTP Response를 리턴하는 컴포넌트로서, Model로부터 데이타를 읽거나 저장할 수 있으며, Template을 호출하여 데이타를 UI 상에 표현하도록 할 수 있다. 

MTV의 Template은 Presentation Logic 만을 갖는데 HTML을 생성하는 것을 목적으로 하는 컴포넌트이다.



## Django Template

 "App폴더/templates/App명/템플릿파일" 처럼, 각 App 폴더 밑에 templates 서브폴더를 만들고 다시 그 안에 App명을 사용하여 서브폴더를 만든 후 템플릿 파일을 그 안에 넣기를 권장한다 (예: /home/templates/home/index.html ).

 대부분의 경우 View로부터 어떤 데이타를 전달받아 HTML 템플릿 안에 그 데이타를 동적으로 치환해서 사용한다. 

1. 먼저 View (home/views.py)에서 다음과 같이 index()를 정의

```python
from django.shortcuts import render

def index(request):
    msg= 'My Message'
    return render(request, 'index.html', {'message': msg})
```

- `render`

  - func in django.shrtcuts 패키지

  - (request, template, optional)

    - template은 home/templates/index.htm를 가리키게 됨(ex)

    - optional

       View에서 템플릿에 전달한 데이타를 Dictionary로 전달한다. 

2. 다음으로 Template (home/templates/index.html)에 HTML 문서를 작성한다. 

Django의 템플릿에서 {{ 변수명 }} 은 해당 변수의 값을 그 자리에 치환하라는 의미를 갖는다.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>{{message}}</h1>
</body>
</html>
```



### 템플릿 설정

Django에서는 여러 템플릿 엔진을 선택하여 사용할 수 있으며, 이 셋팅은 Django 프로젝트의 settings.py 에서 할 수 있다. 


### Django 템플릿 언어

#### 템플릿 변수

```django
<h4>
  Name : {{ name }}
  Type : {{ vip.key }}
</h4>
```

#### 템플릿 태그

```django
# {$ something $}
{% if count > 0 %}
    Data Count = {{ count }}
{% else %}
    No Data
{% endif %}
 
{% for item in dataList %}
  <li>{{ item.name }}</li>
{% endfor %}
 
{% csrf_token %}
```

#### 템플릿 필터

템플릿 필터는 변수의 값을 특정한 포맷으로 변형하는 기능을 한다. 

```django
날짜 포맷 지정
{{ createDate|date:"Y-m-d" }}
 
소문자로 변경
{{ lastName|lower }}
```

#### 코멘트

```django
{# 1 라인 코멘트 #}
 
{% comment %}  
  <div>
      <p>
          불필요한 블럭
      </p>
      <span></span>
  </div>
{% endcomment %}
```



#### HTML Escape

```django
% autoescape on %}     # autoescape 태그
    {{ content }}
{% endautoescape %}
 
{{ content|escape }}    # escape 필터
```





## Django Model



데이타 서비스를 제공하는 Layer이다.

models.py 모듈 안에 하나 이상의 모델 클래스를 정의할 수 있으며, 하나의 모델 클래스는 데이타베이스에서 하나의 테이블에 해당된다.

Django 모델은 "django.db.models.Model" 의 파생 클래스이며, 모델의 필드는 클래스의 Attribute로 표현되며 테이블의 컬럼에 해당한다. 

모델 클래스는 필드를 정의하기 위해 인스턴스 변수가 아닌 클래스 변수를 사용하는데, 이는 그 변수가 테이블 컬럼의 내용을 갖는 것이 아니라, 테이블의 컬럼 메타 데이타를 정의하는 것이기 때문이다.



### 필드 타입

필드 타입 클래스 이외에, Django 프레임워크는 테이블 간 혹은 필드 간 관계(Relationship)을 표현하기 위해 ForeignKey, ManyToManyField, OneToOneField 클래스를 또한 제공하고 있다. 

특히 ForeignKey는 모델 클래스간 (혹은 Underlying 테이블 간) Many-To-One (혹은 One-To-Many) 관계를 표현하기 위해 흔히 사용된다.

 이 부분에 대한 보다 자세한 내용은 [이 링크](https://docs.djangoproject.com/es/1.11/ref/models/fields/#module-django.db.models.fields.related)를 참조한다.



### 필드 옵션

 필드 옵션은 일반적으로 생성자에서 아규먼트로 지정한다. 다음은 모든 필드 타입에 적용 가능한 옵션들 중 자주 사용되는 몇가지를 요약한 것이다.

| 필드 옵션                       | 설명                                                         |
| :------------------------------ | :----------------------------------------------------------- |
| null (Field.null)               | null=True 이면, Empty 값을 DB에 NULL로 저장한다. DB에서 Null이 허용된다. 예: models.IntegerField(null=True) |
| blank (Field.blank)             | blank=False 이면, 필드가 Required 필드이다. blank=True 이면, Optional 필드이다. 예: models.DateTimeField(blank=True) |
| primary_key (Field.primary_key) | 해당 필드가 Primary Key임을 표시한다. 예: models.CharField(max_length=10, primary_key=True) |
| unique (Field.unique)           | 해당 필드가 테이블에서 Unique함을 표시한다. 해당 컬럼에 대해 Unique Index를 생성한다. 예: models.IntegerField(unique=True) |
| default (Field.default)         | 필드의 디폴트값을 지정한다. 예: models.CharField(max_length=2, default="WA") |
| db_column (Field.db_column)     | 컬럼명은 디폴트로 필드명을 사용하는데, 만약 다르게 쓸 경우 지정한다. |





## DB 설정과 Migration

Django에서 Model 클래스를 생성하고 난 후, 해당 모델에 상응하는 테이블을 데이타베이스에서 생성할 수 있다. 

> Python 모델 클래스의 수정 (및 생성 )을 DB에 적용하는 과정을 Migration이라 부른다.

### 준비하는 과정과 이를 적용하는 과정

1. settings.py 파일 안의 INSTALLED_APPS 리스트에 (만약 이미 추가되지 않았다면) 해당 Django App (예: feedback)을 추가한다.

2. 모델 클래스로부터 테이블 스키마를 생성 혹은 수정하기 위하여 아래 명령을 실행한다. 이 명령이 실행되면 해당 Django App 안에 migrations 라는 서브폴더를 만들고 테이블 생성 및 수정을 위한 파이썬 마이크레이션 파일들을 생성한다.

   ```
   $ ./manage.py makemigrations
   ```

3. 모델 클래스로부터 실제 DB에 테이블을 생성하거나 수정하기 위해 아래 명령을 실행한다. 이는 실제 Migration을 DB에 적용하는 명령이다.

   ```
   $ ./manage.py migrate
   ```



### DB관리 Shell

데이타베이스 관리를 위해 "manage.py dbshell" 명령을 사용할 수 있다. Migration이 완료되면 아래와 같이 dbshell 을 사용하여 생성된 테이블과 테이블의 컬럼 정보, 혹은 테이블 내용 등을 확인할 수 있다.

```
$ ./manage.py dbshell
```

![](http://pythonstudy.xyz/images/django/dbshell.png)



### DB 설정

Django 에서 사용하는 DB 에 대한 정보는 Django 프로젝트의 settings.py 파일에 설정되어 있다.





## Django 모델 API

[앞의 Django 모델](http://pythonstudy.xyz/python/article/308-Django-모델-Model)에서처럼 모델 클래스를 정의하게 되면, Django는 데이타를 추가/갱신하고 읽어 들일 수 있는 다양한 데이타베이스 API 들을 자동으로 제공한다. 이러한 기능은 Django가 ORM 서비스를 기본적으로 제공함에 따른 것으로 데이타베이스를 편리하게 핸들링할 수 있게 도와준다.



### INSERT

```python
from feedback.models import * # ex)
from datetime import datetime
 
# Feedback 객체 생성
fb = Feedback(name = 'Kim', email = 'kim@test.com', comment='Hi', createDate=datetime.now())
 
# 새 객체 INSERT
fb.save()
```



### SELECT

Django는 디폴트로 모든 Django 모델 클래스에 대해 "objects" 라는 Manager (django.db.models.Manager) 객체를 자동으로 추가한다 (이 objects라는 이름을 변경할 수도 있지만, 대부분 그대로 사용한다). 

Django 에서 제공하는 이 Manager를 통해 특정 데이타를 필터링 할 수도 있고 정렬할 수도 있으며 기타 여러 기능들을 사용할 수 있다.

데이타를 읽어오기 위해서는 Django 모델의 Manager 즉 "모델클래스.objects" 를 사용한다

- all()

- get()

  하나의 Row만을 가져옴

  ```
  row = Feedback.objects.get(pk=1)
  print(row.name)
  ```

- filter()

  특정 조건에 맞는 Row들을 가져오기 위해서는 filter() 메서드를 사용

  ```
  rows= Feedback.objects.filter(name='kim')
  ```

- exclude()

  특정 조건을 제외한 나머지 Row들을 가져오기 위해서는 exclude() 메서드를 사용

  ```
  rows= Feedback.objects.exclude(name='kim')
  ```

- count()

  데이타의 갯수(row 수)를 세기 위해 count() 메서드를 사용

  ```
  n= Feedback.objects.count()
  ```

- order_by() //sort

  데이타를 키에 따라 정렬하기 위해 order_by() 메서드를 사용한다. order_by() 안에는 정렬 키를 나열할 수 있는데, 앞에 -가 붙으면 내림차순이다. 아래는 id를 기준으로 올림차순, createDate로 내림차순으로 정렬하게 된다.

  ```
  rows= Feedback.objects.order_by('id', '-createData')
  ```

- distinct()

  중복된 값은 하나로만 표시하기 위해 distinct() 메서드를 사용한다. SQL의 SELECT DISTINCT 와 같은 효과를 낸다. 아래는 name필드가 중복되는 경우 한번만 표시하게 된다.

  ```
  rows= Feedback.objects.distinct('name')
  ```

- first()

  데이타들 중 처음에 있는 row만 리턴.

  아래는 name 필드로 정렬했을 때 처음 row 를 리턴

  ```
  rows= Feedback.objects.order_by('name').first()
  ```

- last()

  데이타들 중 마지막에 있는 row만을 리턴한다. 아래는 name필드로 정렬했을 때 마지막 row를 리턴한다.

  ```
  rows= Feedback.objects.order_by('name').last()
  ```

 쿼리 메서드들은 하나 하나가 실제 데이타 결과를 직접 리턴한다기 보다는 쿼리 표현식(Django에서 QuerySet이라 한다)을 리턴하는데, 여러 메서드들을 체인처럼 연결하여 사용할 수 있다. 즉, 여러 체인으로 연결되어 리턴된 쿼리가 해석되어 DB에 실제 하나의 쿼리를 보내게 된다. 



### UPDATE

 데이타를 수정하기 위해서는 먼저 수정할 Row 객체를 얻은 후 변경할 필드들을 수정한다. 이어 마지막에 save() 메서드를 호출되면, SQL의 UPDATE이 실행되어 테이블에 데이타가 갱신된다. 

아래는 id가 1인 Feedback 객체에 이름을 변경하는 코드이다.

```
fb= Feedback.objects.get(pk=1)
fb.name= 'Park'
fb.save()
```



### DELETE

데이타를 삭제하기 위해서는 먼저 삭제할 Row 객체를 얻은 후 delete() 메서드를 호출하면 된다. 아래는 id가 2인 Feedback 객체를 삭제하는 코드이다.

```
fb= Feedback.objects.get(pk=2)
fb.delete()
```




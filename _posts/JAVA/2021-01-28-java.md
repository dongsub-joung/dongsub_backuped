---
title: Java tips in TCP SCHOOL.com
tag: java
---  

## 스트림 API(Stream API)  
자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용  
-> 재사용 불가, 가독성 x :데이터베이스의 쿼리와 같이 정형화된 처리 패턴을 가지지 못했기에 데이터마다 다른 방법으로 접근해야만 했다.  

> 스트림 API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다.

### 특징  

1. internal iteration을 통해 작업을 수행.(컬렉션은 외부 반복)  
2. 스트림은 단 한 번만 사용할 수 있다.(컬렉션은 재사용이 가능함.)  
3. 원본 데이터를 변경하지 않음.  
4. 스트림의 연산은 filter-map 기반의 API를 사용 lazy연산을 통해 성능을 최적화한다.  
5. parallelStream() 메소드를 통한 쉬운 병렬 처리를 지원.  
  
![흐름](http://www.tcpschool.com/java/java_stream_concept)  


### 적용  

```java  
String[] arr= new String[]{"넷", "둘", "셋", "하나"};

// 배열에서 스트림 생성
Stream<String> stream_1= Arrays.stream(arr);
stream_1.forEach(e->System.out.print(e+""));
System.out.println();

// 배열의 특정 부분만을 이용한 스트림 생성
Stream<String> stream_2= Arrays.stream(arr, 1,3);
stream_2.forEach(e->System.out.print(e+""));
```  

"컬렉션, 배열등의 저장 요소를 하나씩 참조하며 함수형 인터페이스(람다식)를 적용하며 반복적으로 처리할 수 있도록 해주는 기능"  

```java  
List<String> names= Arrays.asList("jeong", "pro","jdk", "java");

// 스트림
count= 0;
count= names.stream().filter(x -> x.contains("o")).count();
System.out.println("Count : " + count);

// 기존 방식
long count= 0;
for(String name: names)
{
  if(name.contains("o"))
  {
    count++;
  }
}
System.out.println("Count: " + count);
```  

[기본기를 쌓는 정아마추어 코딩블로그](https://jeong-pro.tistory.com/165)


---

## 실수의 표현  

- 부동 소수점(floating point) 방식

실수는 보통 정수부와 소수부로 나누지만, 가수부와 지수부로 나누어 표현할 수도 있습니다.

부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식입니다.  

---  

## 메모리 구조  

![메모리 구조](http://www.tcpschool.com/lectures/img_java_memory_structure.png)  

[정리](http://www.tcpschool.com/java/java_array_memory)  

---  

## 배열  

자바에서 배열은 한 번 생성하면 그 길이를 변경할 수 없습니다. 따라서 더 많은 데이터를 저장하기 위해서는 더욱 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사해야 합니다.  

1. System class's arraycopy()  
2. Arrays class's copyOf()  
3. Object class's clone()  
4. for && index를 사용한 복사  

- 성능: arraycopy() 메소드  
- 유연함: copyOf()  


```java  
int[] arr_1= new int[]{1,2,3,4,5};
int newLen= 10;

// 1. 
int[] arr_2= new int[newLen]; // size 10
System.arraycopy(arr_1, 0, arr_2, 0, arr_1.length);
// public static void arraycopy(Object src,
//              int srcPos,   (starting position in the source array.)
//              Object dest,
//              int destPos,  (starting position in the destination data.)
//              int length)   (the number of array elements to be copied.)


// 2.
int[] arr_3= Arrays.copyOf(arr_1, 10);

// 3. 
int[] arr_4= (int[]) arr_1.clone();

// 4. 
int[] arr_5= new int[newLen];
```

- output  

```
1 2 3 4 5 0 0 0 0 0 

1 2 3 4 5 0 0 0 0 0 

1 2 3 4 5 

1 2 3 4 5 0 0 0 0 0 
```

---  

## 메소드 오버로딩  

- 메소드 시그니처: 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킵니다. 만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면, 이 두 메소드의 시그니처는 같다고 할 수 있습니다.  

> 같은 이름의 메소드를 중복하여 정의하는 것을 의미합니다. 
> 자바에서는 원래 한 클래스 내에 같은 이름의 메소드를 둘 이상 가질 수 없습니다.
> 하지만 매개변수의 개수나 타입을 다르게 하면, 하나의 이름으로 메소드를 작성할 수 있습니다.
> 즉, 메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이라고 할 수 있습니다.  

---  

## abstract method  

자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미한다.  





## etc

- 자바에서는 유니코드(unicode)를 사용하여 문자를 표현합니다.  
  유니코드는 문자 하나를 16비트로 표현하므로, 총 65,536개의 문자를 표현할 수 있습니다.  

- 인스턴스란 메모리에 할당된 객체를 의미합니다.  

- this() 메소드  
  생성자 내에서 다른 생성자를 사용  

- protected  

![protected](http://www.tcpschool.com/lectures/img_java_access_protected.png)  


- static  
  1. 프로그램 시작시 최조에 단 한번만 생성되고 초기화됨.  
  2. 인스턴스를 생성하지 않고도 바로 사용할 수 있게 됨.  
  3. 해당 클래스의 모든 인스턴스가 공유합니다.  

- 인스턴스 블록  
  생성자와 인스턴스 초기화 블록의 차이는 거의 없으므로 인스턴스 초기화 블록은 잘 사용되지 않습니다.  
  단, 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드의 중복을 막을 수 있습니다.  





## 참조  

- [docs.oracle.com](https://docs.oracle.com/javase/7/docs/api/java/lang/System.html)  


### 추상 클래스  
- [heartflow89](https://m.blog.naver.com/heartflow89/220963055326)  

- [limkydev](https://limkydev.tistory.com/188)  

---
title: new 와 delete를 사용한 동적 메모리 할당
tag: cpp
---



C++은 세 가지 기본 타입의 메모리 할당을 지원한다.

+ 정적 메모리 할당, static memory allcation

  정적 변수와 전역변수에 대해 발생한다. 이러한 타입의 변수에 대한 메모리는 프로그램이 실행될 때 한 번 할당되며, 프로그램 수명 내내 지속한다



+ 자동 메모리 할당, autu memory allocation

  함수 매개 변수와 지역 변수에 대해 발생한다. 이러한 타입의 변수에 대한 메모리는 관련 블록을 입력할 때 할당되고, 블록을 종료할 때 필요에 따라 여러 번 해제된다.



+ 동적 메모리 할당 dynamic memory allocation



---

상위 두개의 메모리 할당은 공통점이 있다.

+ 변수/배열의 크기는 컴파일 타임에 알아야 한다.

+ 메모리 할당 및 해제가 자동으로 수행된다. (변수가 인스턴스화/제거되는 경우)

---

> 메모리에 할당할 변수 크기에 대한 문제

​	**동적 메모리 할당은 프로그램 실행 중에 필요한 메모리를 운영체제에 요청하는 방법이다.** 이 메모리는 프로그램의 제한된 **스택(stack)** 메모리에서 할당되는 것이 아니라 **힙(heap)**이라는 운영체제에서 관리하는 훨씬 더 큰 메모리 풀에서 할당된다. 최신 시스템에서는 힙 크기가 기가바이트 단위가 될 수 있다.

---

## dynamically allocating single variablese

단일 변수 할당은 `new`연산자를 사용.

`new`연산자는 해당 메모리를 사용하여 객체를 만든 다음 할당된 메모리의 주소가 포함된 포인터를 반환한다.

할당된 메모리에 나중에 접근할 수 있도록 반환 값을 자체 포인터 변수에 할당한다.

```
int *ptr = new int;
```

```
클래스이름 *포인터변수 =  new 클래스이름; //기본 생성자 호출
클래스이름 *포인터변수 =  new 클래스이름(생성자매개변수);
```



그럼 다음 포인터를 역참조(dereference)하여 메모리에 접근할 수 있다.

```
*ptr = 7;
```

방금 할당된 메모리의 주소를 유지하는 포인터가 없으면 할당된 메모리에 접근할 수 없다.

---

## Deleting single variables

동적으로 할당된 변수를 모두 사용하면 메모리를 해제하여 재사용할 수 있도록 C++에 명시적으로 알려야 한다. 단일 변수의 경우 `delete` 연산자를 통해 수행된다.

```
delete ptr;
ptr=0;
```

```
delete 포인터 변수;
```



`delete` 연산자는 실제로 아무것도 삭제하지 않는다. 단순히 가리키는 메모리를 다신 운영 체제로 반환하다. 그러면 운영 체제에서 해당 메모리를 다른 응용 프로그램에 다시 할당할 수 있다.

변수를 삭제하는 것처럼 보이지만 사실이 아니다! 포인터 변수는 여전히 이전과 동일한 범위를 가지며 다른 변수와 마찬가지로 새 값을 할당받을 수 있다.

동적으로 할당된 메모리를 가리키지 않는 포인터를 삭제하면 나쁜일이 발생할 수 있다.

---

## Dangling pointers

할당이 해제된 메모리를 가리키는 포인터를 **댕글링 포인터(dangling pointer)**라고 한다. 댕글링 포인터를 역참조하거나 삭제하면 정의되지 않은 동작이 발생한다.

위 프로그램에서 이전에 할당된 메모리에 할당된 7의 값은 여전할 수 있지만, **해당 메모리의 주소의 값이 변경되었을 수 있다. 또한, 메모리가 다른 응용 프로그램에 할당될 수 있으며 해당 메모리에 접근하려고 하면 운영 체제가 프로그램을 종료시킨다.**

> 먼저, 여러 포인터가 같은 동적 메모리를 가리키는 것을 피하자.
>
> 둘째, 포인터를 삭제할 때 포인터를 0 또는 nullptr로 설정하자.



## Null pointers and dynamic memory allocation

## Memory leak

출처: https://boycoding.tistory.com/204 [소년코딩]


---
title: reference
tag: cpp
---



[CPP](https://modoocode.com/141)

---

C 언어에서는 어떠한 변수를 가리키고 싶을 땐 반드시 포인터를 사용해야만 했다.

But, C++ 에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공하는데, 이를 바로 **참조자(레퍼런스 - reference)** 라고 부른다.

---

참조자를 정하는 방법은, 가리키고자 하는 타입 뒤에 `&` 를 붙이면 됩니다.

```
int a = 3;
int& another_a = a;
```

**참조자를 사용한다는 것은 참조하는 이 변수가 참조되는 변수의 또 다른 이름 이라고 컴파일러에게 알려주는 것**

따라서 `another_a` 에 어떠한 작업을 수행하든 이는 사실상 `a` 에 그 작업을 하는 것과 마찬가지 입니다.

참조자와 포인터는 상당히 유사한 개념입니다. 

포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산을 수행할 수 있기 때문이죠. 하지만 레퍼런스와 포인터는 몇 가지 중요한 차이점이 있습니다.

---

+ 레퍼런스는 정의 시에 반드시 누구의 별명인지 명시 해야 함.

```
int& a; // 불가능
int* p; // 가능
```

+ 한 번 어떤 변수의 참조자가 되버린다면, 이 더이상 다른 변수를 참조할 수 없게 됩니다.

+ 레퍼런스는 메모리 상에 존재하지 않을 수 도 있다.

만일 내가 컴파일러라면 `another_a` 위해서 메모리 상에 공간을 할당할 필요가 있을까요? 아니죠! 왜냐하면 `another_a` 가 쓰이는 자리는 모두 `a` 로 바꿔치기 하면 되니까요. 따라서 이 경우 레퍼런스는 메모리 상에 존재하지 않게 됩니다. 물론 그렇다고 해서 항상 존재하지 않은 것은 아닙니다. 

> 함수의 인자로 존재할 때

---

+  C++ 문법 상 참조자의 참조자를 만드는 것은 금지되어 있습니다.
+  참조자를 사용하게 되면 불필요한 `&` 와 `*` 가 필요 없기 때문에 코드를 훨씬 간결하게 나타낼 수 있습니다.
+ C++ 문법 상 상수 리터럴을 일반적인 레퍼런스가 참조하는 것은 불가능하게 되어 있습니다.

```cpp
//대신
const int &ref = 4;
int a = ref; // a=4;
```

**주소값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다** 라는 의미와 같습니다. 하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지 하지 않습니다. 따라서 이러한 모순 때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지가 되어 있는 것입니다.

but , 포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해선 반드시 배열의 크기를 명시해야 합니다.

---

+ Dangling reference

레퍼런스는 있는데 원래 참조 하던 것이 사라진 레퍼런스를 댕글링 레퍼런스 (Dangling reference) 라고 부릅니다. *Dangling* 이란 단어의 원래 뜻은 약하게 결합대서 **달랑달랑** 거리는 것을 뜻하는데, 레퍼런스가 참조해야 할 변수가 사라져서 혼자서 덩그러니 남아 있는 상황과 유사하다고 보시면 됩니다.

---

```cpp
//외부 변수의 레퍼런스를 리턴
int& function(int& a) 
{
  a = 5;
  return a;
}

int main() 
{
  int b = 2;
  int c = function(b);
  return 0;
}
```

그렇다면 이렇게 참조자를 리턴하는 경우의 장점이 무엇일까요? C 언어에서 엄청나게 큰 구조체가 있을 때 해당 구조체 변수를 그냥 리턴하면 전체 복사가 발생해야 해서 시간이 오래걸리지만, 해당 구조체를 가리키는 포인터를 리턴한다면 그냥 포인터 주소 한 번 복사로 매우 빠르게 끝납니다.

마찬가지로 레퍼런스를 리턴하게 된다면 **레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한 번의 주소값 복사로 전달이 끝나게 됩니다**. 따라서 매우 효율적이죠!

---

#### 참조자가 아닌 값을 리턴하는 함수를 참조자로 받기

원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 정상입니다. 따라서 기존에 `int&` 로 받았을 때에는 컴파일 자체가 안되었습니다. 하지만 예외적으로 **상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장됩니다**. 그리고 그 연장되는 기간은 레퍼런스가 사라질 때 까지 입니다.

---

함수의 매개변수로 레퍼런스를 전달할 때는 주소를 전달한다라고 하셨는데, 이것을 힙, 스택, 데이터 메모리 영역 분리 관점에서 호출 스택이 추가될 때 주소값을 전달한다.

1) 호출 스택이 달라질 때, 해당 메모리에 접근하기 위해 주소가 필요하다. 주소 메모리 공간이 필요하다. 

2) 호출 스택이 같을 때, 바로 접근하며 따로 주소 메모리 공간이 불필요하다. 이렇게 생각해도 될까요?
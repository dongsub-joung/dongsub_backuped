---
title: virtual function
tag: cpp
---



# [virtual function](https://modoocode.com/210)

---

## is-a 와 has -a

실제 이유는 상속이라는 기능을 통해서 객체지향프로그래밍에서 추구하는 실제 객체의 추상화를 좀 더 효과적으로 할 수 있게 되었습니다.

```cpp
class Manager : public Employee
```

의 의미는,

- `Manager` 클래스는 `Employee` 의 모든 기능을 포함한다
- `Manager` 클래스는 `Employee` 의 기능을 모두 수행할 수 있기 때문에 (Manager 에게는 약간 기분 나쁘겠지만) `Manager` 를 `Employee` 라고 칭해도 무방하다
- 즉, 모든 `Manager` 는 `Employee` 이다.

 상속의 또 하나의 중요한 특징을 알 수 있습니다. 바로 클래스가 파생되면 파생될 수 록 좀 더 **특수화 (구체화;specialize)** 된다는 의미 입니다. 즉, `Employee` 클래스가 일반적인 사원을 위한 클래스 였다면 `Manager` 클래스 들은 그 일반적인 사원들 중에서도 좀 더 특수한 부류의 사원들을 의미하게 됩니다.

반대로, 기반 클래스로 거슬러 올라가면 올라갈 수 록 좀 더 **일반화 (generalize)** 된다고 말합니다.

---

## dyanmic_cast

C++ 에서는 상속 관계에 있는 두 포인터들 간에 캐스팅을 해주는 `dynamic_cast` 라는 것을 지원합니다. 이를 사용하는 방법은 `static_cast` 와 거의 동일합니다.

```cpp
Derived* p_c = dyanmic_cast<Derived*>(p_p); // 컴파일 오류
```

---

```cpp
class EmployeeList {
  int alloc_employee;  // 할당한 총 직원 수

  int current_employee;  // 현재 직원 수
  int current_manager;   // 현재 매니저 수

  Employee **employee_list;  // 직원 데이터
  Manager **manager_list;    // 매니저 데이터
  // ...
```

위와 같은 구성에서 가장 문제가 되는 것이 각 클래스 별로 데이터를 따로 보관해야 된다는 것입니다. 즉 `Employee` 들은 `Employee *` 가 가리켜야 하고, `Manager` 들은 `Manager *` 가 가리켜야 합니다. 만일 무한 상사에서 클래스 하나를 더 추가해달라고 연락이 왔다간 때릴 지도 모르겠지요.

하지만, 한 가지 위에서 배운 사실은, 업 캐스팅은 매우 자유롭게 수행될 수 있다는 점입니다. 즉, `Employee *` 가 `Manager` 객체를 가리켜도 별 문제가 없다는 것이지요. 그렇다면 `manager_list` 를 그냥 지워 버리고, `employee_list` 가 `Employee, Manager` 상관없이 가리키게 해도 될까요? 그러면 참 좋겠지만 다음과 같은 문제점이 있습니다.

와 같이 전부다 `Employee` 의 `print_info` 와 `calculate_pay` 함수가 호출되서 원래 결과와 달라집니다.

그런데 놀랍게도 이러한 문제를 5초 만에 해결할 수 있는 방법이 있습니다.

---

## virtual 키워드

이렇게 컴파일 시에 어떤 함수가 실행될 지 정해지지 않고 런타임 시에 정해지는 일을 가리켜서 **동적 바인딩(dynamic binding)** 이라고 부릅니다. 즉,

론 동적 바인딩의 반대말로 **정적 바인딩(static binding)** 이란 말도 있습니다. 이는 컴파일 타임에 어떤 함수가 호출될 지 정해지는 것으로 여태까지 여러분이 알고 오셨던 함수에 해당합니다.

덧붙여서, `virtual` 키워드가 붙은 함수를 **가상 함수(virtual function)** 라고 부릅니다. 이렇게 파생 클래스의 함수가 기반 클래스의 함수를 오버라이드 하기 위해서는 두 함수의 꼴이 정확히 같아야 합니다.

---

```cpp
void what() override { std::cout << s << std::endl; }
```

위 경우 `Derived` 클래스의 `what` 함수는 `Base` 클래스의 `what` 함수를 오버라이드 하므로, `override` 키워드를 통해 이를 알려주고 있습니다.

소드를 호출했음에도 불구하고 여러가지 다른 작업들을 하는 것을 바로 **다형성(polymorphism)** 이라고 부릅니다.

참고로, 다형성을 뜻하는 영어 단어인 *polymorphism* 은,여러개를 의미하는 그리스어 'poly' 와, 모습, 모양을 뜻하는 그리스어 'morphism' 에서 온 단어로 '여러가지 형태' 라는 의미 입니다.